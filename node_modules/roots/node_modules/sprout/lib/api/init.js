// Generated by CoffeeScript 1.7.0
(function() {
  var Base, Init, S, W, dns, ejs, exec, fs, inquirer, ncp, nodecb, nodefn, path, readdirp, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path = require('path');

  fs = require('fs');

  W = require('when');

  nodefn = require('when/node');

  nodecb = require('when/callbacks');

  readdirp = require('readdirp');

  ncp = require('ncp').ncp;

  exec = require('child_process').exec;

  ejs = require('ejs');

  inquirer = require('inquirer');

  Base = require('../base');

  S = require('string');

  _ = require('lodash');

  dns = require('dns');

  Init = (function(_super) {
    var add_defaults_to_questions, check_internet_connection, checkout_version, configure_options, copy_template, ensure_template_is_updated, get_user_init_file, install_template_dependencies, merge_config_values_with_overrides, parse_version, prompt_user_for_answers, remove_overrides_from_prompt, replace_ejs, run_user_after_function, run_user_before_function, run_user_before_render_function;

    __extends(Init, _super);

    function Init() {
      Init.__super__.constructor.apply(this, arguments);
    }

    Init.prototype.execute = function(opts) {
      return configure_options.call(this, opts)["with"](this).then(install_template_dependencies).then(get_user_init_file).then(run_user_before_function).then(remove_overrides_from_prompt).then(add_defaults_to_questions).then(prompt_user_for_answers).then(merge_config_values_with_overrides).then(check_internet_connection).then(ensure_template_is_updated).then(checkout_version).then(copy_template).then(run_user_before_render_function).then(replace_ejs).then(run_user_after_function).then(function() {
        return "project created at '" + this.target + "'!";
      });
    };

    Init.prototype.remove = function(f) {
      return fs.unlinkSync(path.resolve(this.target, f));
    };


    /**
     * @private
     */

    configure_options = function(opts) {
      if (!opts || !opts.name) {
        return W.reject('your template needs a name!');
      }
      this.name = opts.name;
      this.target = opts.path;
      this.overrides = opts.overrides || [];
      this.defaults = opts.defaults;
      this.answers = {};
      this.version = parse_version(this.name) || '';
      if (this.version.length) {
        this.name = this.name.replace(this.version, '').slice(0, -1);
      }
      this.sprout_path = this.path(this.name);
      if (Array.isArray(this.overrides)) {
        this.overrides = this.overrides.reduce((function(_this) {
          return function(m, v, i) {
            if (i % 2 === 0) {
              m[v] = _this.overrides[i + 1];
            }
            return m;
          };
        })(this), {});
      }
      if (!fs.existsSync(this.sprout_path)) {
        return W.reject("template '" + this.name + "' does not exist");
      }
      if (!this.target) {
        this.target = path.join(process.cwd(), this.name);
      }
      return W.resolve();
    };

    parse_version = function(name) {
      var match;
      match = name.match(/@+([^@]*)$/);
      if (match) {
        return match[1];
      } else {
        return false;
      }
    };

    install_template_dependencies = function() {
      var p;
      p = path.join(this.sprout_path, 'package.json');
      if (fs.existsSync(p)) {
        return nodefn.call(exec, "npm install", {
          cwd: this.sprout_path
        });
      }
    };

    get_user_init_file = function() {
      var init_file;
      init_file = path.join(this.sprout_path, 'init.coffee');
      if (!fs.existsSync(init_file)) {
        return this.config = {};
      }
      return this.config = require(init_file);
    };

    run_user_before_function = function() {
      if (!this.config.before) {
        return W.resolve();
      }
      return nodefn.call(this.config.before, this);
    };

    remove_overrides_from_prompt = function() {
      var keys;
      keys = _.keys(this.overrides);
      return this.questions = _.reject(this.config.configure, function(v) {
        return _.contains(keys, v.name);
      });
    };

    add_defaults_to_questions = function() {
      var i, q, val, _i, _len, _ref, _results;
      if (!this.defaults) {
        return;
      }
      _ref = this.questions;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        q = _ref[i];
        if (val = _.find(this.defaults, function(v, k) {
          return k === q.name;
        })) {
          _results.push(this.questions[i]["default"] = val);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    prompt_user_for_answers = function() {
      if (!this.questions.length) {
        return W.resolve();
      }
      return nodecb.call(inquirer.prompt, this.questions).then((function(_this) {
        return function(o) {
          return _this.answers = o;
        };
      })(this));
    };

    merge_config_values_with_overrides = function() {
      return this.config_values = _.assign(this.answers, this.overrides);
    };

    check_internet_connection = function() {
      return nodefn.call(dns.resolve, 'google.com').then(function() {
        return true;
      })["catch"](function() {
        return false;
      });
    };

    ensure_template_is_updated = function(internet) {
      if (!internet) {
        return W.resolve();
      }
      return nodefn.call(exec, "git pull", {
        cwd: this.sprout_path
      })["catch"](function() {
        return W.resolve();
      });
    };

    checkout_version = function() {
      return nodefn.call(exec, "git tag -l", {
        cwd: this.sprout_path
      }).then((function(_this) {
        return function(res) {
          var cmd, versions, _ref, _ref1;
          versions = _.compact(res[0].split('\n'));
          if (!versions.length) {
            return W.resolve();
          }
          if (!_this.version.length) {
            cmd = "git checkout tags/" + versions[versions.length - 1];
            return nodefn.call(exec, cmd, {
              cwd: _this.sprout_path
            });
          }
          if (_ref = _this.version, __indexOf.call(versions, _ref) >= 0) {
            cmd = "git checkout tags/" + _this.version;
            return nodefn.call(exec, cmd, {
              cwd: _this.sprout_path
            });
          }
          if (_ref1 = "v" + _this.version, __indexOf.call(versions, _ref1) >= 0) {
            cmd = "git checkout tags/v" + _this.version;
            return nodefn.call(exec, cmd, {
              cwd: _this.sprout_path
            });
          }
          return W.reject(new Error('version does not exist'));
        };
      })(this));
    };

    copy_template = function() {
      var root_path;
      root_path = path.join(this.sprout_path, 'root');
      if (!fs.existsSync(root_path)) {
        return W.reject('template does not contain root directory');
      }
      return nodefn.call(ncp, root_path, this.target);
    };

    run_user_before_render_function = function() {
      if (!this.config.before_render) {
        return W.resolve();
      }
      return nodefn.call(this.config.before_render, this);
    };

    replace_ejs = function() {
      return nodefn.call(readdirp, {
        root: this.target
      }).tap((function(_this) {
        return function(res) {
          var ejs_options;
          ejs_options = _.extend(_this.config_values, {
            S: S
          });
          return res.files.map(function(f) {
            var out;
            out = ejs.render(fs.readFileSync(f.fullPath, 'utf8'), ejs_options);
            return fs.writeFileSync(f.fullPath, out);
          });
        };
      })(this));
    };

    run_user_after_function = function() {
      if (!this.config.after) {
        return W.resolve();
      }
      return nodefn.call(this.config.after, this);
    };

    return Init;

  })(Base);

  module.exports = function(opts) {
    return (new Init()).execute(opts);
  };

}).call(this);
