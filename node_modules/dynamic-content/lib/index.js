// Generated by CoffeeScript 1.7.0
(function() {
  var W, fs, os, path, yaml, _;

  path = require('path');

  fs = require('fs');

  _ = require('lodash');

  yaml = require('js-yaml');

  W = require('when');

  os = require('os');

  module.exports = function() {
    var DynamicContent;
    return DynamicContent = (function() {
      var after_hook, all_fn, before_hook, detect_fn, write_hook;

      function DynamicContent() {
        this.category = 'dynamic';
      }

      DynamicContent.prototype.fs = function() {
        return {
          extract: true,
          ordered: true,
          detect: detect_fn
        };
      };

      DynamicContent.prototype.compile_hooks = function() {
        return {
          before_pass: before_hook.bind(this),
          after_file: after_hook.bind(this),
          write: write_hook.bind(this)
        };
      };


      /**
       * Read the first three bytes of each file, if they are '---', assume
       * that we're working with dynamic content.
       *
       * @private
       *
       * @param  {File} file - vinyl-wrapped file instance
       * @return {Boolean} promise returning true or false
       */

      detect_fn = function(file) {
        var deferred, res;
        deferred = W.defer();
        res = false;
        fs.createReadStream(file.path, {
          encoding: 'utf-8',
          start: 0,
          end: 3
        }).on('error', deferred.reject).on('end', function() {
          return deferred.resolve(res);
        }).on('data', function(data) {
          if (data.split(os.EOL.substring(0, 1))[0] === "---") {
            return res = true;
          }
        });
        return deferred.promise;
      };


      /**
       * For dynamic files before the last compile pass:
       * - remove the front matter, parse into an object
       * - add the object to the locals, nesting as deep as the folder it's in
       * - add an "all" utility function to each level
       *
       * @private
       *
       * @param  {Object} ctx - roots context
       */

      before_hook = function(ctx) {
        var br, f, file_locals, folders, front_matter, front_matter_str, i, locals, regex, roots, _base, _i, _len, _results;
        if (ctx.index === ctx.file.adapters.length) {
          f = ctx.file;
          roots = f.roots;
          br = "\\" + os.EOL;
          regex = new RegExp("^---\s*" + br + "([\\s\\S]*?)" + br + "?---\s*" + br + "?");
          front_matter_str = ctx.content.match(regex);
          front_matter = yaml.safeLoad(front_matter_str[1]);
          ctx.content = ctx.content.replace(front_matter_str[0], '');
          folders = path.dirname(f.file.relative).split(path.sep);
          locals = (_base = f.compile_options).site != null ? _base.site : _base.site = {};
          file_locals = f.file_options;
          front_matter._categories = folders;
          front_matter._url = roots.config.out(f.file, ctx.adapter.output).replace(roots.config.output_path(), '');
          _results = [];
          for (i = _i = 0, _len = folders.length; _i < _len; i = ++_i) {
            f = folders[i];
            if (locals[f] == null) {
              locals[f] = [];
            }
            locals = locals[f];
            if (i === folders.length - 1) {
              locals.push(front_matter);
              locals.all = all_fn;
              _results.push(file_locals.post = locals[locals.length - 1]);
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        }
      };


      /**
       * After a file in the category has been compiled, grabs the content and
       * adds it to the locals object unless _content key is false
       *
       * @private
       *
       * @param  {Object} ctx - roots context
       * @return {Boolean}
       */

      after_hook = function(ctx) {
        var locals;
        locals = ctx.file_options.post;
        if (locals._content !== false) {
          return locals.content = ctx.content;
        }
      };


      /**
       * If a dynamic file has `_render` set to false in the locals, don't write
       * the file. Otherwise write as usual.
       *
       * @param  {Object} ctx - roots context
       * @return {Boolean} whether or not to write the file as usual
       */

      write_hook = function(ctx) {
        return !(ctx.file_options.post._render === false);
      };


      /**
       * Returns an array of all the dynamic conteent object in the folder
       * it was called on, as well as every folder nested under it, flattened
       * into a single array.
       *
       * @private
       *
       * @return {Array} Array of dynamic content objects
       */

      all_fn = function() {
        var recurse, values;
        values = [];
        recurse = function(obj) {
          var o, _i, _len, _ref, _results;
          _ref = Object.keys(obj);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            o = _ref[_i];
            if (!isNaN(parseInt(o))) {
              values.push(obj[o]);
              continue;
            }
            _results.push(recurse(obj[o]));
          }
          return _results;
        };
        recurse(this);
        return values;
      };

      return DynamicContent;

    })();
  };

}).call(this);
